struct skin_patch
# Skinware - User API
version version 1.0.0.894
author Shahbaz Youssefi
keyword skin
keyword middleware
keyword skinware
keyword DIST
keyword MacLAB
shortcut index
shortcut globals
shortcut constants
previous struct skin_sensor
next struct skin_module
seealso `[skin_sensor]`
seealso `[skin_module]`
seealso `[skin_sensor_iterator]`
seealso `[#skin_object_patches](skin_object)`

The `skin_patch` struct holds data of one patch in the skin.

VARIABLE id: skin_patch_id
	Id of the patch

	The id of the patch. This value is equal to the patch's index in the patch list obtainable via `[#skin_object_patches](skin_object)` function.
	If the value of `id` is equal to `[#SKIN_INVALID_ID](constants)`, that means the patch is not properly initialized. See also
	`[#skin_patch_id](skin_object)`.

VARIABLE modules_begin: skin_module_id
	Where the modules belonging to this patch start

	The modules of each patch are stored consequently. They are located in the modules list obtainable via `[#skin_object_modules](skin_object)` function,
	with indices in \[`modules_begin`, `[#modules_end]`). See also `[#skin_module_id](skin_object)`.

VARIABLE modules_end: skin_module_id
	Where the modules belonging to this patch end

	The modules of each patch are stored consequently. They are located in the modules list obtainable via `[#skin_object_modules](skin_object)` function,
	with indices in \[`[#modules_begin]`, `modules_end`). See also `[#skin_module_id](skin_object)`.

VARIABLE sensor_type_id: skin_sensor_type_id
	Id of the type of the sensors of this patch

	The id of the type of the sensors of this patch. See `[#id](skin_sensor_type)` of `skin_sensor_type`.

FUNCTION skin_patch_init: (patch: skin_patch *): void
	Initialize patch to invalid

	Initializer of the struct. Sets the patch variables so that the patch would be invalid.

	INPUT patch
		The object of operation

FUNCTION skin_patch_free: (patch: skin_patch *): void
	Free module

	Free any resources and invalidate the patch.

	INPUT patch
		The object of operation

FUNCTION skin_patch_modules: (patch: skin_patch *, count: skin_module_size *): skin_module *
	Gives an array of modules belonging to this patch

	This function returns a reference to a part of the [modules array](skin_object#skin_object_modules) where the modules of this patch are located.
	That is modules from index `[#modules_begin]`. The array will have **`count`** elements. Note that this is **not** a copy of the modules array,
	but a reference to the original. See also `[#skin_module_size](skin_object)`.

	INPUT patch
		The object of operation
	INPUT count
		After `skin_patch_modules` finishes, this variable will hold the number of modules in this patch.

		If `NULL`, it will be left untouched.
	OUTPUT
		As output, this function returns an array of modules belonging to this patch. If the patch is not properly initialized,
		this function will return `NULL` and the input **`count`** will be left untouched.

FUNCTION skin_patch_sensors_count: (patch: skin_patch *): skin_sensor_size
	Gives the number of sensors belonging to this patch

	The output of this function is equal to the sum of `count` argument of `[#skin_module_sensors](skin_module)` for all modules of this patch.
	This value however is cached in the patch and is therefore more efficient to be retrieved in this way.

	INPUT patch
		The object of operation
	OUTPUT
		The number of sensors in this patch.

FUNCTION skin_patch_modules_count: (patch: skin_patch *): skin_module_size
	Gives the number of modules belonging to this patch

	The output of this function is equal to the `count` argument of `[#skin_patch_modules]`.

	INPUT patch
		The object of operation
	OUTPUT
		The number of modules in this patch.

FUNCTION skin_patch_sensor_type: (patch: skin_patch *): skin_sensor_type *
	Gives the type of the sensors of this patch

	This function returns a reference to the type of sensors of this patch. This is the same as writing
		```
		\&[#skin_object_sensor_types](skin_object)(\&skin, NULL)\[patch->[#sensor_type_id]\]
		```
	where `skin` is the skin object (of type `[skin_object]`) and `patch` is the **`patch`** parameter of this function.

	INPUT patch
		The object of operation
	OUTPUT
		A reference to the type of sensors of this patch

FUNCTION skin_patch_for_each_sensor: (patch: skin_patch *, c: skin_callback_sensor, data: void *): void
	Call a callback for all sensors of patch

	This function iterates over sensors of **`patch`** calling [callback](skin_callbacks#skin_callback_sensor) **`c`** with additional data **`data`**.
	This iteration stops when either all sensors have been iterated or the callback returns `[#SKIN_CALLBACK_STOP](constants)`.

	INPUT patch
		The object of operation
	INPUT c
		The callback to be called
	INPUT data
		User defined data

FUNCTION skin_patch_for_each_module: (patch: skin_patch *, c: skin_callback_module, data: void *): void
	Call a callback for all modules of patch

	This function iterates over modules of **`patch`** calling [callback](skin_callbacks#skin_callback_module) **`c`** with additional data **`data`**.
	This iteration stops when either all modules have been iterated or the callback returns `[#SKIN_CALLBACK_STOP](constants)`.

	INPUT patch
		The object of operation
	INPUT c
		The callback to be called
	INPUT data
		User defined data

MEMBER_TYPE skin_sensor_iterator: opaque
NOTICE C++
	A sensor iterator

	Returned by `[#sensors_iter_begin]` and `[#sensors_iter_end]`. Please see the [generic iterator page](skin_X_iterator).

MEMBER_TYPE skin_module_iterator: opaque
NOTICE C++
	A module iterator

	Returned by `[#modules_iter_begin]` and `[#modules_iter_end]`. Please see the [generic iterator page](skin_X_iterator).

MEMBER_FUNCTION skin_patch: ()
NOTICE C++
	Class constructor

	Default constructor of the class. Calls `[#skin_patch_init]`.

MEMBER_FUNCTION ~skin_patch: ()
NOTICE C++
	Class destructor

	Destructor of the class. Calls `[#skin_patch_free]`.

MEMBER_FUNCTION modules: (count: skin_module_size * = NULL): skin_module *
NOTICE C++
	Wrapper for `skin_patch_modules`

	Calls `[#skin_patch_modules]`.

	INPUT count
		See `[#skin_patch_modules]`.
	OUTPUT
		See `[#skin_patch_modules]`.

MEMBER_FUNCTION sensors_count: (): skin_sensor_size
NOTICE C++
	Wrapper for `skin_patch_sensors_count`

	Calls `[#skin_patch_sensors_count]`.

	OUTPUT
		See `[#skin_patch_sensors_count]`.

MEMBER_FUNCTION modules_count: (): skin_module_size
NOTICE C++
	Wrapper for `skin_patch_modules_count`

	Calls `[#skin_patch_modules_count]`.

	OUTPUT
		See `[#skin_patch_modules_count]`.

MEMBER_FUNCTION sensor_type: (): skin_sensor_type *
NOTICE C++
	Wrapper for `skin_patch_sensor_type`

	Calls `[#skin_patch_sensor_type]`.

	OUTPUT
		See `[#skin_patch_sensor_type]`.

MEMBER_FUNCTION sensors_iter_begin: (): skin_patch::skin_sensor_iterator
NOTICE C++
	Gives an iterator to iterate over sensors of this patch

	This function returns a pointer of type `skin_patch::[#skin_sensor_iterator]`, similar to C++'s STL `iterator` classes, which points to the first of
	this patch's sensors. This iterator can then be used to traverse all sensors of this patch. Note that the sensors traversed are not a copy and the
	iterators actually point to the original data.

	OUTPUT
		The output of this function is an iterator over sensors of this patch, pointing to the first one.

MEMBER_FUNCTION sensors_iter_end: (): const skin_patch::skin_sensor_iterator
NOTICE C++
	Gives an invalid iterator marking the end of iteration over the sensors

	This function returns a pointer of type `skin_patch::[#skin_sensor_iterator]`, similar to C++'s STL `iterator` classes, which points to an invalid
	sensor. This iterator can then be used in comparison with another iterator to determine whether that iterator has reached the end of its range.
	This is similar to how iterators are used in C++'s STL.

	OUTPUT
		The output of this function is an iterator over sensors of this patch pointing to an invalid sensor (and therefore should not be dereferenced).

MEMBER_FUNCTION modules_iter_begin: (): skin_patch::skin_module_iterator
NOTICE C++
	Gives an iterator to iterate over modules of this patch

	This function returns a pointer of type `skin_patch::[#skin_module_iterator]`, similar to C++'s STL `iterator` classes, which points to the first of
	this patch's modules. This iterator can then be used to traverse all modules of this patch. Note that the modules traversed are not a copy and the
	iterators actually point to the original data.

	OUTPUT
		The output of this function is an iterator over modules of this patch, pointing to the first one.

MEMBER_FUNCTION modules_iter_end: (): const skin_patch::skin_module_iterator
NOTICE C++
	Gives an invalid iterator marking the end of iteration over the modules

	This function returns a pointer of type `skin_patch::[#skin_module_iterator]`, similar to C++'s STL `iterator` classes, which points to an invalid
	module. This iterator can then be used in comparison with another iterator to determine whether that iterator has reached the end of its range.
	This is similar to how iterators are used in C++'s STL.

	OUTPUT
		The output of this function is an iterator over modules of this patch pointing to an invalid module (and therefore should not be dereferenced).
