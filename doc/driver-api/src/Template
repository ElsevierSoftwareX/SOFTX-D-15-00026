example Template
# Skinware - Driver API
version version 1.0.0.872
author Shahbaz Youssefi
keyword skin
keyword middleware
keyword skinware
keyword DIST
keyword MacLAB
shortcut index
shortcut globals
shortcut constants
previous api Data Types
next api Callbacks

This is an example of a conforming driver. It has network specific parts missing and can therefore be used as a template for drivers.

```
#include \<linux/module.h>
#include \<linux/kernel.h>
#include \<linux/kthread.h>

#define SKINK_MODULE_NAME "template_driver"
`#include \<skink.h>`

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Shahbaz Youssefi");

typedef struct layer_data
{
	char               name\[SKINK_MAX_NAME_LENGTH + 1];
	skink_sensor_size  sensors_count;
	skink_module_size  modules_count;
	skink_patch_size   patches_count;
	uint32_t           acquisition_rate;
	skink_module_id    module_data_begin;
	skink_patch_id     patch_data_begin;
	uint32_t           extra;
} layer_data;

typedef struct module_data
{
	skink_sensor_size  sensors_count;
} module_data;

typedef struct patch_data
{
	skink_module_size  modules_count;
} patch_data;

static skink_sensor_layer_size  the_layers_count;
static layer_data               *the_layers;
static module_data              *the_modules;
static patch_data               *the_patches;

static struct task_struct       *_initialization_task;
static bool                     _busy                        = false;
static bool                     _initialization_task_exited  = false;
static bool                     _must_exit                   = false;

``static int                      _device_id                   = -1;``

static int init_network(void)
{
	/* Initialize the network */
}

static void stop_network(void)
{
	/* Stop the network */
}

static int init_data(void)
{
	/* Initialize the internal data structures, i.e. the_layers etc */
}

static void free_data(void)
{
	/* Free data allocated by init_data */
}

/* The details callback: */
static `void details(skink_sensor_layer *layer)`
{
	uint32_t i;
	layer_data *layer_here = ``the_layers + layer->id_in_device``;
	if (the_layers == NULL || the_modules == NULL || the_patches == NULL)  /* Should not happen if there is no bug */
	{
		SKINK_LOG("details called while the device is not properly initialized");
		return;
	}
	``strncpy(layer->name, layer_here->name, SKINK_MAX_NAME_LENGTH);``
	``layer->name\[SKINK_MAX_NAME_LENGTH] = '\\0';``
	``layer->sensors_count = layer_here->sensors_count;``
	``layer->modules_count = layer_here->modules_count;``
	``layer->patches_count = layer_here->patches_count;``
	``layer->acquisition_rate = layer_here->acquisition_rate;``
	``for (i = 0; i < layer_here->modules_count; ++i)``
		``layer->modules\[i].sensors_count = the_modules\[layer_here->module_data_begin + i].sensors_count;``
	``for (i = 0; i < layer_here->patches_count; ++i)``
		``layer->patches\[i].modules_count = the_patches\[layer_here->patch_data_begin + i].modules_count;``
}

/* The busy callback: */
static `void busy(bool b)`
{
	``_busy = b;``
}

/* The acquire callback: */
static `int acquire(skink_sensor_layer *layer, skink_sensor_id *skinmap, uint8_t buffer)`
{
	skink_sensor_id i;
	skink_sensor_response skin_val;
	skin_rt_time t = skin_rt_get_time();
	char turn_off = 0;
#if BITS_PER_LONG != 64
	skin_rt_time temp;
#endif
	t = (t>>15) + layer->id_in_device * 0x3fff;	/* make t & 0xffff about 2 seconds (with an offset to distinguish layers) */
#if BITS_PER_LONG != 64
	temp = t;
	skin_val = do_div(temp, SKINK_SENSOR_RESPONSE_MAX);	/* changes temp and returns temp%SKINK_SENSOR_RESPONSE_MAX */
	turn_off = temp & 1;
#else
	skin_val = t % SKINK_SENSOR_RESPONSE_MAX;
	turn_off = (t / SKINK_SENSOR_RESPONSE_MAX) & 1;
#endif
	if (turn_off)			/* make an effect of turning on gradually in 2 seconds and off in another 2 seconds (and in a cycle) */
		skin_val = SKINK_SENSOR_RESPONSE_MAX - skin_val;
	`for (i = 0; i < layer->sensors_count; ++i)`
		``layer->sensors\[skinmap\[i]].response\[buffer] = skin_val;``
	``return SKINK_SUCCESS;``
}

static int init_thread(void *arg)
{
	``skink_registration_data data;``
	int ret;
	uint32_t i;
	skink_sensor_size sensors_count = 0;
	skink_module_size modules_count = 0;
	skink_patch_size patches_count = 0;
	SKINK_LOG("Init thread: Stage 1...");
	/* Stage 1: Network initialization */
	if (`init_network()`)
	{
		SKINK_LOG("Stage 1: Template driver module stopping due to error in network initialization!");
		_initialization_task_exited = true;
		do_exit(0);
		return 0;
	}
	/* Stage 2: Data initialization */
	if (`init_data()`)
	{
		SKINK_LOG("Stage 2: Template driver module stopping due to error in data initialization!");
		_initialization_task_exited = true;
		do_exit(0);
		return 0;
	}
	`for (i = 0; i < the_layers_count; ++i)`
	{
		`modules_count += the_layers\[i].modules_count`;
		`patches_count += the_layers\[i].patches_count`;
		`sensors_count += the_layers\[i].sensors_count`;
	}
	SKINK_LOG("Init thread: Stage 2...done");
	SKINK_LOG("Init thread: Stage 3...");
	/* Stage 3: registering device */
	``data.sensor_layers_count = the_layers_count;``
	``data.sensors_count = sensors_count;``
	``data.modules_count = modules_count;``
	``data.patches_count = patches_count;``
	``data.details_callback = details;``
	``data.busy_callback = busy;``
	``data.acquire_callback = acquire;``
	``data.device_name = SKINK_MODULE_NAME;``
	while (!_must_exit)
	{
		bool revived;
		``ret = skink_device_register_nonblocking(&data, &revived);``
		`if (ret >= 0)`
		{
			if (revived)
				SKINK_LOG("Stage 2: Revived!");
			``_device_id = ret``;
		}
		`else if (ret == SKINK_IN_USE)`
		{
			SKINK_LOG("Stage 3: Template driver module stopping because another device with same name is in use!");
			goto exit_done;
		}
		`else if (ret == SKINK_TOO_LATE)`
		{
			SKINK_LOG("Stage 3: Template driver module stopping because it is introduced to the skin kernel too late!");
			goto exit_done;
		}
		`else if (ret == SKINK_BAD_DATA)`
		{
			SKINK_LOG("Stage 3: Template driver module stopping because Skinware rejected its registration data!");
			goto exit_done;
		}
		`else if (ret == SKINK_TOO_EARLY)`
		{
			`set_current_state(TASK_INTERRUPTIBLE);`
			`msleep(1);`
			/* And retry */
		}
		else /* This should not happen if there is no bug */
		{
			SKINK_LOG("Stage 3: Got unknown return value from Skinware: %d!", ret);
			goto exit_done;
		}
	}
	`if (!_must_exit && _device_id >= 0)`
	{
		if (``skink_device_resume(_device_id)`` != SKINK_SUCCESS)
			SKINK_LOG("Stage 3: Error - Failed to resume network");
		else
			SKINK_LOG("Init thread: Stage 3...done");
	}
exit_done:
	_initialization_task_exited = true;
	do_exit(0);
	return 0;		// should never reach
}

int init_module(void)
{
	SKINK_LOG("Template driver module initializing...");
	SKINK_LOG("Using skin kernel version %s", SKINK_VERSION);
	``_busy = false;``
	_initialization_task_exited = false;
	_must_exit = false;
	if ((_initialization_task = kthread_run(init_thread, NULL, "template_driver_init_thread")) == ERR_PTR(-ENOMEM))
	{
		_initialization_task = NULL;
		SKINK_LOG("Error creating the initial thread!");
		SKINK_LOG("Stopping functionality!");
		_initialization_task_exited = true;
		return -ENOMEM;
	}
	SKINK_LOG("Template driver module initializing...done!");
	return 0;
}

void cleanup_module(void)
{
	SKINK_LOG("Template driver module exiting...");
	_must_exit = true;
	/* Make sure init thread is finished, so skink_device_paused and skink_device_resume wouldn't be called simultaneously */
	``while (!_initialization_task_exited)``
	{
		``set_current_state(TASK_INTERRUPTIBLE);``
		``msleep(1);``
	}
	`if (_device_id >= 0)`
		``skink_device_pause(_device_id);``
	if (_busy)
		SKINK_LOG("Still in use by Skinware.  Waiting...");
	/* Block until the skin kernel says the device is not busy */
	``while (_busy)``
	{
		``set_current_state(TASK_INTERRUPTIBLE);``
		``msleep(1);``
	}
	`stop_network();`
	`free_data();`
	SKINK_LOG("Template driver module exiting...done!");
}

```
