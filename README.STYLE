					   Coding style of Skinware
					   ========================

Skinware uses the underscore style.  This means that every word is separated by `_`.  Upper-case letters in names are forbidden, except in macros of course.
This means that camelCase for example is not to be used.

These are additional rules to follow:

- In the library, every struct must be prefixed with `skin_`
- In the library, every macro must be prefixed with `SKIN_` and written in UPPER-CASE
- In the kernel, every function/struct must be prefixed with `skink_`
- In the kernel, every macro must be prefixed with `SKINK_` and written in UPPER-CASE
- Private variables need to be prefixed by `p_`, for example p_object
- Global variables shared between files need to be prefixed by `the_` in kernel and `the_skin_` in the library.  Currently, there are none in the library.
- Static variables and functions need to be prefixed by `_`
- Use 8-width tabs
- Put space around binary arithmatic/boolean operators, but not others (Do: + - | >> *(binary)..., Don't: sizeof, *(unary), ->, ?:, ...)
- If breaking a statement in two lines at an operator, put the operator in the next line (this includes = also).  Align same-depth operators, even if it
  means using space.  On the other hand, indent more if you break inside parentheses.  For example:

	result = some_variable1
		 + some_variable2
		 + some_variable3 * (some_variable4
			+ some_variable5)
		 + some_variable6;

- There are no restrictions in line width.  All developer monitors today are big enough for 150 or more characters per line, so keeping line width to 80 is unnecessary.
  Keeping it below about 120 or so may not be bad though.  If you worked on Skinware and noticed lines getting wrapped in your monitor, well then,
  that is proof that smaller monitors still live!  In such a case, kindly break the lines and send a pull request.  This way, we keep the line width to the
  minimum we need, not some extra-small 80 characters.
- DON'T write doxygen style commenting before each function.  Try to write function/parameter names in a clear way instead.  If you want to comment on the function,
  do so in the header file for everyone to see, not in the source only for developers.  If you have something important to say about the function, do so in
  the documentation file as well as the header.  That is, please don't clutter the code with a lot of documentation stuff.  Documentation stuff goes in
  documentation file, not the source file.  Putting documentation in the source has the disadvantage that it would be impossible to know if the documentation is
  updated with respect to changes in the function.
- Put opening and closing braces of code blocks each in one line.  So write like this:

	if (a > b)
	{
		/* Do this */
	}
	else
	{
		/* Do that */
	}

  I am aware that Kernighan and Ritchie liked to open brace in the same line as `if`, but I personally find it much easier to identify matching braces when
  they are both written in separate lines.  Besides, a few almost-empty lines every now and then makes the code a bit easier to read.  Anyway, you don't have
  to do whatever the creators of what you like did!  I mean, if Einstein liked to write his formula in Comic Sans, that doesn't mean you should also use Comic Sans
  when applying E=MC^2 to your work.

  Instead to distinguish, put opening and closing braces of initializer blocks in K&R style.  For example:

	object = (struct something){
		.mem = val,
	};

- Don't use extra spaces after opening and before closing parentheses.  So, do NOT write like this:

	if ( a > b )  /* This is bad */

- If defining a macro to use within only one function, it is fine to use local variables or gotos inside the macro.  However, put the definition of the macro inside the
  function itself (rather than above it), preferably next to where it is first used.  Undef the macro at the bottom of the function if there is a chance for it
  be used elsewhere by mistake.
  * Rationale: Defining the macro inside the function both makes it clear that the macro is specific to that function, and it provides the code being produced
    (code generated by the macro) directly in the function itself so it's easier to follow what's going on inside the macro.  Exceptions being macros that are
    very obvious what they do.
